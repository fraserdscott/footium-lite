{"version":3,"file":"graphql-126ef292.js","sources":["../../../../../src/lib/utils/graphql/constants.ts","../../../../../src/lib/utils/graphql/endpoint.ts","../../../../../src/lib/blockchain/subgraph.ts","../../../../../src/lib/utils/stores/base.ts","../../../../../src/lib/utils/stores/graphql.ts"],"sourcesContent":["export const initialState: {\n  fetching: boolean;\n  stale: boolean;\n  error: unknown;\n  data?: Record<string, unknown>;\n  extensions?: Record<string, unknown>;\n} = {\n  fetching: false,\n  stale: false,\n  error: undefined,\n  data: undefined,\n  extensions: undefined,\n};\n","import {Client, defaultExchanges} from '@urql/core';\nimport type {OperationContext, OperationResult} from '@urql/core';\nimport {devtoolsExchange} from '@urql/devtools';\nimport type {DocumentNode} from 'graphql';\nimport {pipe, fromValue, concat, scan, map, subscribe} from 'wonka';\nimport {initialState} from './constants';\nimport type {sourceT} from 'wonka/dist/types/src/Wonka_types.gen';\n\nexport type InternalQueryState<T> = {\n  fetching: boolean;\n  stale: boolean;\n  data: T;\n  error: unknown;\n  extensions: Record<string, unknown>;\n};\n\nconst exchanges = defaultExchanges.concat();\n\nif (import.meta.env.MODE === 'development') {\n  exchanges.unshift(devtoolsExchange);\n}\n\nexport class EndPoint {\n  private client: Client;\n  constructor(url: string) {\n    if (!url) {\n      console.error(`need an url for graphql queries`);\n    } else {\n      this.client = new Client({\n        url,\n        exchanges,\n      });\n    }\n  }\n\n  mutate<Data = unknown, Variables extends Record<string, unknown> = Record<string, unknown>>(\n    query: DocumentNode | string,\n    args?: {\n      variables?: Variables;\n      context?: Partial<OperationContext>;\n    }\n  ): Promise<OperationResult<Data>> {\n    return this.client.mutation(query, args?.variables, args?.context).toPromise();\n  }\n\n  query<Data, Variables extends Record<string, unknown> = Record<string, unknown>>(\n    query: DocumentNode | string,\n    args?: {\n      variables?: Variables;\n      context?: Partial<OperationContext>;\n      // TODO path?: string\n    }\n  ): Promise<OperationResult<Data, Variables>> {\n    return this.client.query(query, args?.variables, args?.context).toPromise();\n  }\n\n  async queryList<T, Variables extends Record<string, unknown> = Record<string, unknown>>(\n    query: DocumentNode | string,\n    args?: {\n      variables?: Variables;\n      context?: Partial<OperationContext>;\n      path?: string;\n      getLastId?: (entries: T[]) => string;\n    }\n  ): Promise<T[]> {\n    const fields = args.path.split('.');\n    const first = 100;\n    let lastId = '0x0';\n    let numEntries = first;\n    let entries: T[] = [];\n    while (numEntries === first) {\n      const result = await this.client.query(query, {first, lastId, ...args?.variables}, args?.context).toPromise();\n      if (result.error) {\n        throw new Error(result.error.message);\n      }\n      const data = result.data;\n\n      // TODO deep access on root array\n      let newEntries = [];\n      if (data && args.path) {\n        let tmp = data;\n        for (const fieldPart of fields) {\n          tmp = tmp[fieldPart];\n        }\n        newEntries = tmp;\n      }\n\n      numEntries = newEntries.length;\n      if (numEntries > 0) {\n        const newLastId = args?.getLastId !== undefined ? args?.getLastId(entries) : newEntries[numEntries - 1].id;\n        if (lastId === newLastId) {\n          console.log('same query, stop');\n          break;\n        }\n        lastId = newLastId;\n      }\n      entries = entries.concat(newEntries);\n    }\n    return entries;\n  }\n\n  subscribeToQuery<\n    Data extends Record<string, unknown>,\n    Variables extends Record<string, unknown> = Record<string, unknown>\n  >(\n    query: DocumentNode | string,\n    args?: {\n      variables?: Variables;\n      context?: Partial<OperationContext>;\n    }\n  ): {\n    subscribe: (value: (value: InternalQueryState<Data>) => void) => () => void;\n  } {\n    const queryResult$ = pipe(\n      concat([\n        fromValue({fetching: true, stale: false}),\n        pipe(\n          this.client.query(query, args?.variables, args?.context),\n          map(({stale, data, error, extensions}) => ({\n            fetching: false,\n            stale: !!stale,\n            data,\n            error,\n            extensions,\n          }))\n        ),\n        fromValue({fetching: false, stale: false}),\n      ]),\n      scan(\n        (result, partial) => ({\n          ...result,\n          ...partial,\n        }),\n        initialState\n      )\n    );\n\n    return {\n      subscribe(onValue) {\n        return pipe(queryResult$ as sourceT<InternalQueryState<Data>>, subscribe(onValue)).unsubscribe;\n      },\n    };\n  }\n}\n","import {EndPoint} from '$lib/utils/graphql/endpoint';\nimport {graphNodeURL} from '$lib/config';\n\nexport const SUBGRAPH_ENDPOINT = new EndPoint(graphNodeURL);\n","import {writable} from 'svelte/store';\nimport type {Readable, Writable} from 'svelte/store';\n\ntype DataType<T> = Record<string, unknown> & {data?: T};\n\n// eslint-disable-next-line @typescript-eslint/explicit-module-boundary-types, @typescript-eslint/no-explicit-any\nfunction _recurseSet(target: any, obj: any) {\n  for (const key of Object.keys(obj)) {\n    if (target[key] && typeof target[key] === 'object' && typeof obj[key] === 'object') {\n      _recurseSet(target[key], obj[key]);\n    } else {\n      target[key] = obj[key];\n    }\n  }\n}\n\nexport class BasicObjectStore<T extends Record<string, number | string>> implements Readable<T> {\n  protected store: Writable<T>;\n  protected __set: (newValue: T) => void;\n  private value: T;\n  private oldValue: T;\n  constructor(initialValue?: T) {\n    this.value = initialValue;\n    this.oldValue = {...initialValue};\n    this.store = writable(this.value, this._start.bind(this));\n  }\n\n  public get $store(): T {\n    return this.value;\n  }\n\n  // eslint-disable-next-line @typescript-eslint/no-unused-vars\n  protected _start(_: (newValue: T) => void): void {\n    return this._stop.bind(this);\n  }\n\n  protected _stop(): void {}\n\n  protected _set(newValue: T): void {\n    let changes = false;\n    if (!this.value) {\n      this.value = {...newValue};\n      changes = true;\n    } else {\n      for (const key of Object.keys(this.oldValue)) {\n        if (newValue[key] !== this.oldValue[key]) {\n          changes = true;\n          (this.value as Record<string, unknown>)[key] = newValue[key];\n        }\n      }\n      for (const key of Object.keys(newValue)) {\n        if (newValue[key] !== this.oldValue[key]) {\n          changes = true;\n          (this.value as Record<string, unknown>)[key] = newValue[key];\n        }\n      }\n    }\n\n    if (changes) {\n      this.oldValue = {...this.value};\n      this.store.set(this.value);\n    }\n  }\n\n  subscribe(run: (value: T) => void, invalidate?: (value?: T) => void): () => void {\n    return this.store.subscribe(run, invalidate);\n  }\n}\n\nexport class BaseStore<T extends Record<string, unknown>> implements Readable<T> {\n  protected store: Writable<T>;\n  constructor(protected readonly $store: T) {\n    this.store = writable(this.$store);\n  }\n\n  subscribe(run: (value: T) => void, invalidate?: (value?: T) => void): () => void {\n    return this.store.subscribe(run, invalidate);\n  }\n\n  protected setPartial(obj: Partial<T>): T {\n    if (!this.$store) {\n      // eslint-disable-next-line @typescript-eslint/no-explicit-any\n      (this.$store as any) = {};\n    }\n    for (const key of Object.keys(obj)) {\n      (this.$store as Record<string, unknown>)[key] = obj[key];\n    }\n    this.store.set(this.$store);\n    return this.$store;\n  }\n  protected set(obj: T): T {\n    if (!this.$store) {\n      // eslint-disable-next-line @typescript-eslint/no-explicit-any\n      (this.$store as any) = {};\n    }\n\n    if (!obj) {\n      // eslint-disable-next-line @typescript-eslint/no-explicit-any\n      (this.$store as any) = obj;\n    }\n    // Testing hmr for subclasses\n    //   const objAny: any = obj;\n    //   objAny.value += 7;\n    if (obj !== this.$store) {\n      for (const key of Object.keys(this.$store)) {\n        if (obj[key] === undefined) {\n          (this.$store as Record<string, unknown>)[key] = undefined;\n        }\n      }\n      for (const key of Object.keys(obj)) {\n        (this.$store as Record<string, unknown>)[key] = obj[key];\n      }\n    }\n    this.store.set(this.$store);\n    return this.$store;\n  }\n}\n\nexport class BaseStoreWithData<T extends DataType<U>, U> extends BaseStore<T> {\n  constructor($store: T) {\n    super($store);\n  }\n\n  protected setData(data: Partial<U>, extra?: Partial<T>): T {\n    this.$store.data = this.$store.data || ({} as U); // this assume setData was set before ?\n    _recurseSet(this.$store.data, data);\n    if (extra) {\n      this.setPartial(extra);\n    }\n    this.store.set(this.$store);\n    return this.$store;\n  }\n}\n\nexport abstract class AutoStartBaseStore<T extends Record<string, unknown>> extends BaseStore<T> {\n  private _listenerCount = 0;\n  private _stopUpdates?: () => void;\n  subscribe(run: (value: T) => void, invalidate?: (value?: T) => void): () => void {\n    this._listenerCount++;\n    if (this._listenerCount === 1) {\n      console.info(`starting...`);\n      this._stopUpdates = this._onStart();\n    }\n    const unsubscribe = this.store.subscribe(run, invalidate);\n    return () => {\n      this._listenerCount--;\n      if (this._listenerCount === 0) {\n        console.info(`stopping`);\n        if (this._stopUpdates) {\n          this._stopUpdates();\n          this._stopUpdates = undefined;\n        }\n      }\n      unsubscribe();\n    };\n  }\n\n  abstract _onStart(): (() => void) | undefined;\n}\n","import type {EndPoint} from '../graphql/endpoint';\nimport type {Readable} from 'svelte/store';\nimport {BaseStoreWithData} from './base';\nimport {logs} from 'named-logs';\nconst console = logs('graphql');\n\ntype ChainTempoInfo = {lastBlockNumber?: number; stale: boolean};\n\nexport type Hook = {subscribe: (f: (chainInfo: ChainTempoInfo) => void) => () => void};\n\nexport type QueryState<T> = {\n  step: 'IDLE' | 'LOADING' | 'READY';\n  data?: T;\n  error?: string;\n};\n\nexport type ListOptions =\n  | {\n      path?: string;\n      getLastId?: (entries: unknown[]) => string;\n    }\n  | boolean;\n\nexport type QueryStore<T> = Readable<QueryState<T>> & {\n  acknowledgeError: () => void;\n};\n\nexport type QueryStoreWithFetch<T> = QueryStore<T> & {\n  fetch(extraVariables?: Record<string, unknown>): Promise<void>;\n};\n\nexport type QueryStoreWithRuntimeVariables<T> = QueryStoreWithFetch<T> & {\n  runtimeVariables: Record<string, string>;\n};\n\nclass BaseQueryStore<T, V extends Record<string, unknown> = Record<string, unknown>>\n  extends BaseStoreWithData<QueryState<T>, T>\n  implements QueryStoreWithRuntimeVariables<T>\n{\n  public runtimeVariables: Record<string, string> = {};\n  public constructor(\n    private endpoint: EndPoint,\n    private query: string,\n    private options?: {\n      variables?: V;\n      path?: string;\n      list?: ListOptions;\n    }\n  ) {\n    super({\n      step: 'IDLE',\n    });\n  }\n\n  acknowledgeError(): void {\n    this.setPartial({error: undefined});\n  }\n\n  async fetch(extraVariables?: Record<string, unknown>): Promise<void> {\n    console.info('fetching....');\n    const first =\n      typeof this.options?.variables?.first === 'number' ? (this.options?.variables?.first as number) : 1000;\n    let numEntries = first;\n    let lastId = '0x0';\n    let data: T;\n    // eslint-disable-next-line @typescript-eslint/no-explicit-any\n    let list: any[];\n    while (numEntries === first) {\n      try {\n        const variables = {first, lastId, ...this.options?.variables, ...this.runtimeVariables, ...extraVariables};\n        const querySplitted = this.query.split('?');\n        let query = '';\n        for (let i = 0; i < querySplitted.length; i++) {\n          const split = querySplitted[i];\n          if (split.startsWith('$')) {\n            if (!variables[split.substr(1)]) {\n              i++; // skip\n            }\n          } else {\n            query += split;\n          }\n        }\n        const result = await this.endpoint.query<Record<string, unknown>, V>(query, {\n          variables,\n          context: {\n            requestPolicy: 'cache-and-network', // required as cache-first will not try to get new data\n          },\n        });\n\n        if (!result.data) {\n          this.setPartial({error: `cannot fetch from thegraph node`});\n          throw new Error(`cannot fetch from thegraph node`);\n        }\n\n        const freshData = (this.options?.path ? result.data[this.options.path] : result.data) as T;\n        if (!data) {\n          data = freshData;\n        }\n\n        if (this.options?.list) {\n          // eslint-disable-next-line @typescript-eslint/no-explicit-any\n          let freshList = freshData as unknown as any[];\n          if (typeof this.options.list !== 'boolean' && this.options.list.path) {\n            // eslint-disable-next-line @typescript-eslint/no-explicit-any\n            freshList = freshData[this.options.list.path] as any[];\n          }\n\n          numEntries = freshList.length;\n          if (numEntries > 0) {\n            const newLastId =\n              typeof this.options.list !== 'boolean' && this.options.list.getLastId !== undefined\n                ? this.options.list.getLastId(freshList)\n                : freshList[numEntries - 1].id;\n            if (lastId === newLastId) {\n              console.log('same query, stop');\n              break;\n            }\n            lastId = newLastId;\n          }\n\n          if (!list) {\n            list = freshList;\n          } else {\n            list.push(...freshList);\n          }\n        } else {\n          numEntries = 0; // stop the loop\n        }\n      } catch (e) {\n        numEntries = 0;\n        console.error(e);\n      }\n    }\n    this.setPartial({data, step: 'READY'});\n  }\n}\n\nexport class TimedQueryStore<T, V extends Record<string, unknown> = Record<string, unknown>>\n  extends BaseQueryStore<T, V>\n  implements QueryStore<T>\n{\n  private timeout: NodeJS.Timeout;\n  private extraOptions: {frequency?: number};\n  public constructor(\n    endpoint: EndPoint,\n    query: string,\n    options?: {\n      variables?: V;\n      path?: string;\n      frequency?: number;\n    }\n  ) {\n    super(endpoint, query, options);\n    this.extraOptions = options;\n  }\n\n  acknowledgeError(): void {\n    this.setPartial({error: undefined});\n  }\n\n  async fetch(): Promise<void> {\n    await super.fetch();\n    this.timeout = setTimeout(this.fetch.bind(this), (this.extraOptions?.frequency || 1) * 1000);\n  }\n\n  start(): QueryStore<T> {\n    if (this.$store.step === 'IDLE') {\n      this.setPartial({step: 'LOADING'});\n    }\n    if (this.timeout) {\n      clearTimeout(this.timeout);\n    }\n    this.fetch();\n    return this;\n  }\n\n  stop(): void {\n    this.setPartial({step: 'IDLE'});\n    if (this.timeout) {\n      clearTimeout(this.timeout);\n      this.timeout = undefined;\n    }\n  }\n}\n\nexport class HookedQueryStore<T, V extends Record<string, unknown> = Record<string, unknown>>\n  extends BaseQueryStore<T, V>\n  implements QueryStore<T>\n{\n  private hook: Hook;\n  public constructor(\n    endpoint: EndPoint,\n    query: string,\n    hook: Hook,\n    options?: {\n      variables?: V;\n      path?: string;\n      list?: ListOptions;\n    }\n  ) {\n    super(endpoint, query, options);\n    this.hook = hook;\n  }\n\n  acknowledgeError(): void {\n    this.setPartial({error: undefined});\n  }\n\n  private listenerCount = 0;\n  private stopUpdates?: () => void;\n  subscribe(run: (value: QueryState<T>) => void, invalidate?: (value?: QueryState<T>) => void): () => void {\n    this.listenerCount++;\n    if (this.listenerCount === 1) {\n      console.info(`start fetching`);\n      this.stopUpdates = this.hook.subscribe((chainInfo: ChainTempoInfo) =>\n        this.fetch({blockNumber: chainInfo.lastBlockNumber})\n      );\n    }\n    const unsubscribe = this.store.subscribe(run, invalidate);\n    return () => {\n      this.listenerCount--;\n      if (this.listenerCount === 0) {\n        console.info(`stop fetching`);\n        if (this.stopUpdates) {\n          this.stopUpdates();\n          this.stopUpdates = undefined;\n        }\n      }\n      unsubscribe();\n    };\n  }\n}\n"],"names":["defaultExchanges","Client","concat","fromValue","map","scan","subscribe","console"],"mappings":"ufAAa,GAMT,CACF,SAAU,GACV,MAAO,GACP,MAAO,OACP,KAAM,OACN,WAAY,QCKR,EAAYA,EAAiB,gBAMb,CAEpB,YAAY,EAAa,CAClB,OAGE,OAAS,GAAIC,GAAO,CACvB,MACA,sBAJM,MAAM,mCASlB,OACE,EACA,EAIgC,OACzB,MAAK,OAAO,SAAS,EAAO,iBAAM,UAAW,iBAAM,SAAS,YAGrE,MACE,EACA,EAK2C,OACpC,MAAK,OAAO,MAAM,EAAO,iBAAM,UAAW,iBAAM,SAAS,iBAG5D,WACJ,EACA,EAMc,MACR,GAAS,EAAK,KAAK,MAAM,KACzB,EAAQ,OACV,GAAS,MACT,EAAa,EACb,EAAe,QACZ,IAAe,GAAO,MACrB,GAAS,KAAM,MAAK,OAAO,MAAM,EAAO,GAAC,QAAO,UAAW,iBAAM,WAAY,iBAAM,SAAS,eAC9F,EAAO,WACH,IAAI,OAAM,EAAO,MAAM,cAEzB,GAAO,EAAO,QAGhB,GAAa,MACb,GAAQ,EAAK,KAAM,IACjB,GAAM,WACC,KAAa,KAChB,EAAI,KAEC,OAGF,EAAW,OACpB,EAAa,EAAG,MACZ,GAAY,kBAAM,aAAc,OAAY,iBAAM,UAAU,GAAW,EAAW,EAAa,GAAG,MACpG,IAAW,EAAW,SAChB,IAAI,4BAGL,IAED,EAAQ,OAAO,SAEpB,GAGT,iBAIE,EACA,EAMA,MACM,GAAe,EACnBC,EAAO,CACLC,EAAU,CAAC,SAAU,GAAM,MAAO,KAClC,EACE,KAAK,OAAO,MAAM,EAAO,iBAAM,UAAW,iBAAM,SAChDC,EAAI,CAAC,CAAC,QAAO,OAAM,QAAO,kBACxB,SAAU,GACV,MAAO,CAAC,CAAC,EACT,OACA,QACA,iBAGJD,EAAU,CAAC,SAAU,GAAO,MAAO,OAErCE,EACE,CAAC,EAAQ,WACJ,GACA,GAEL,UAIG,CACL,UAAU,EAAS,OACV,GAAK,EAAmDC,EAAU,IAAU,oBCxI9E,GAAoB,GAAI,GAAS,GCG9C,WAAqB,EAAa,EAAU,UAC/B,KAAO,QAAO,KAAK,GACxB,EAAO,IAAQ,MAAO,GAAO,IAAS,UAAY,MAAO,GAAI,IAAS,WAC5D,EAAO,GAAM,EAAI,MAEtB,GAAO,EAAI,UA0DyD,CAE/E,YAA+B,EAAW,oBACnC,MAAQ,EAAS,KAAK,QAG7B,UAAU,EAAyB,EAA8C,OACxE,MAAK,MAAM,UAAU,EAAK,GAGzB,WAAW,EAAoB,CAClC,KAAK,QAEP,MAAK,OAAiB,aAEd,KAAO,QAAO,KAAK,GAC3B,KAAK,OAAmC,GAAO,EAAI,eAEjD,MAAM,IAAI,KAAK,QACb,KAAK,OAEJ,IAAI,EAAW,IAClB,KAAK,QAEP,MAAK,OAAiB,IAGpB,GAEF,MAAK,OAAiB,GAKrB,IAAQ,KAAK,OAAQ,UACZ,KAAO,QAAO,KAAK,KAAK,QAC7B,EAAI,KAAS,QACd,MAAK,OAAmC,GAAO,iBAGzC,KAAO,QAAO,KAAK,GAC3B,KAAK,OAAmC,GAAO,EAAI,eAGnD,MAAM,IAAI,KAAK,QACb,KAAK,uBAIiD,EAAa,CAC5E,YAAY,EAAW,OACf,GAGE,QAAQ,EAAkB,EAAuB,aACpD,OAAO,KAAO,KAAK,OAAO,MAAS,KAC5B,KAAK,OAAO,KAAM,GAC1B,QACG,WAAW,QAEb,MAAM,IAAI,KAAK,QACb,KAAK,QC9HhB,KAAMC,GAAU,EAAK,WA+BrB,eACU,EAEV,CAES,YACG,EACA,EACA,EAKR,OACM,CACJ,KAAM,2EAXwC,GAelD,kBAAyB,MAClB,WAAW,CAAC,MAAO,cAGpB,OAAM,EAAyD,qBAC3D,KAAK,qBACP,GACJ,MAAO,YAAK,UAAL,cAAc,YAAd,cAAyB,QAAU,SAAY,WAAK,UAAL,cAAc,YAAd,cAAyB,MAAmB,OAChG,GAAa,EACb,EAAS,MACT,EAEA,OACG,IAAe,MAChB,MACI,GAAY,OAAC,QAAO,UAAW,QAAK,UAAL,cAAc,WAAc,KAAK,kBAAqB,GACrF,EAAgB,KAAK,MAAM,MAAM,QACnC,GAAQ,UACH,GAAI,EAAG,EAAI,EAAc,OAAQ,IAAK,MACvC,GAAQ,EAAc,GACxB,EAAM,WAAW,KACd,EAAU,EAAM,OAAO,YAInB,OAGP,GAAS,KAAM,MAAK,SAAS,MAAkC,EAAO,CAC1E,YACA,QAAS,CACP,cAAe,0BAIf,CAAC,EAAO,gBACL,WAAW,CAAC,MAAO,oCAClB,GAAI,OAAM,wCAGZ,GAAa,SAAK,UAAL,cAAc,MAAO,EAAO,KAAK,KAAK,QAAQ,MAAQ,EAAO,QAC3E,MACI,GAGL,QAAK,UAAL,cAAc,KAAM,IAElB,GAAY,KACZ,MAAO,MAAK,QAAQ,MAAS,WAAa,KAAK,QAAQ,KAAK,SAElD,EAAU,KAAK,QAAQ,KAAK,SAG7B,EAAU,OACnB,EAAa,EAAG,MACZ,GACJ,MAAO,MAAK,QAAQ,MAAS,WAAa,KAAK,QAAQ,KAAK,YAAc,OACtE,KAAK,QAAQ,KAAK,UAAU,GAC5B,EAAU,EAAa,GAAG,MAC5B,IAAW,EAAW,GAChB,IAAI,4BAGL,EAGN,IAGE,KAAK,GAAG,KAFN,SAKI,QAER,KACM,IACL,MAAM,QAGb,WAAW,CAAC,OAAM,KAAM,0BAqDvB,EAEV,CAES,YACL,EACA,EACA,EACA,EAKA,OACM,EAAU,EAAO,sBAQD,OAPjB,KAAO,EAGd,kBAAyB,MAClB,WAAW,CAAC,MAAO,SAK1B,UAAU,EAAqC,EAA0D,MAClG,gBACD,KAAK,gBAAkB,MACjB,KAAK,uBACR,YAAc,KAAK,KAAK,UAAU,AAAC,GACtC,KAAK,MAAM,CAAC,YAAa,EAAU,yBAGjC,GAAc,KAAK,MAAM,UAAU,EAAK,SACvC,IAAM,MACN,gBACD,KAAK,gBAAkB,MACjB,KAAK,iBACT,KAAK,mBACF,mBACA,YAAc"}